# 3. 서블릿, JSP, MVC 패턴


### 템플릿 엔진의 등장

- 서블릿으로 동적인 html을 만들 수 있음 → 복잡 & 비효율

  ⇒ 템플릿 엔진이 나오게 된 이유 : html 문서에서 필요한 곳에만 자바 코드를 적용해 동적으로 변경할 수 있음
- Ex) JSP, Thymleaf, Freemarker, Velocity
  
<br>

### 서블릿과 JSP의 한계

- **서블릿** → 뷰 화면을 위한 html을 만드는 작업이 지저분 & 복잡했음!

  **⇒ 해결 방안 : JSP**
  - 뷰를 생성하는 html 작업을 깔끔하게 하고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용함
  - **JSP의 단점** : 너무 많은 역할을 해서 유지보수가 어려움!

  **⇒ MVC 패턴의 등장! (JSP의 단점 보완하기 위함)****
- 비즈니스 로직 - 서블릿과 같은 다른 곳에서 처리
- JSP - html로 화면을 그리는 일에 집중
  <br>

### MVC패턴 - 개요

- **너무 많은 역할**
- **변경의 라이프 사이클이 다름**
  - UI를 일부 수정하는 일과 비즈니스 로직을 수정하는 일은 각각 다르게 발생할 가능성이 매우 높음 & 서로에게 영향을 주지 X
- **기능 특화**
  - JSP와 같은 뷰 템플릿은 화면을 렌더링 하는데 최적화되어 있음→ 해당 업무만 담당하는 것이 가 효과적
     
<br>

### **Model View Controller**

<img width="900" alt="MVC image" src="https://github.com/Hong-ji-min/Spring_study/assets/80135858/7ae74110-473c-4a2d-a2e9-cf8acc1dd0b1">


- 하나의 서블릿 or JSP로 처리하던 것을 controller와 view라는 영역으로 역할을 나눔!
- 보통 웹 어플리케이션은 보통 mvc 패턴을 사용
  - **모델** : 뷰에 출력할 데이터를 담아둠, 뷰가 필요한 데이터를 모두 모델에 담아 전달해주는 덕분 뷰는 비즈니스 로직 or 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있음
  - **뷰** : 모델에 담겨있는 데이터를 사용해 화면을 그리는 일에 집중함, html을 생성하는 부분을 말함
  - **컨트롤러** : http요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행함

`.getRequestDispatcher(viewPath);` → controller에서 view로 이동할 때 사용

`dispatcher.forward(request, response);` → 다른 서블릿이나 JSP로 이동할 수 있는 기능 / 서버 내부에서 다시 호출이 발생함

`WEB-INF`안의 폴더들은 외부에서 호출해도 호출되지 않는다는 WAS 서버의 룰!

<br>

### **MVC 패턴 - 한계**

- 로직들의 중복
  - 포워드 중복
  - viewpath에 중복
- 공통 처리의 어려움 → 프론트 컨트롤러 패턴으로 해결함!
