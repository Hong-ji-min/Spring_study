# 3. 서블릿, JSP, MVC 패턴


## 템플릿 엔진

- html 문서에서 필요한 곳만 코드를 적용해 동적으로 변경할 수 있음
- 서블릿으로 동적으로 원하는 html을 만들 수 있었지만, 회원의 저장 결과 or 회원 목록과 같은 동적인 html을 만드는 것은 불가능
- 템플릿 엔진이 나오게 된 이유 : html 문서에 동적으로 변경해야 하는 자바 코드를 넣는 것이 더 편리할 것!
- Ex) JSP, Thymleaf, Freemarker, Velocity
  

## 서블릿과 JSP의 한계
- 서블릿 → 뷰 화면을 위한 html을 만드는 작업이 지저분&복잡했음!

    ⇒ <strong>해결 방안 : JSP </strong>
    - 뷰를 생성하는 html 작업을 깔끔하게 하고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용함
    - JSP의 단점 : 너무 많은 역할을 해서 유지보수가 어려움!
#### ⇒ MVC 패턴의 등장! **(JSP의 단점 보완하기 위함)**
- 비즈니스 로직 : 서블릿과 같은 다른 곳에서 처리
- JSP : html로 화면을 그리는 일에 집중
  

## MVC패턴 - 개요
- 너무 많은 역할
- 변경의 라이프 사이클이 다름
    - UI를 일부 수정하는 일과 비즈니스 로직을 수정하는 일은 각각 다르게 발생할 가능성이 매우 높음 & 서로에게 영향을 주지 X
- 기능 특화
    - JSP와 같은 뷰 템플릿은 화면을 렌더링 하는데 최적화되어 있음→ 해당 업무만 담당하는 것이 가 효과적
     

## Model View Controller

- 하나의 서블릿 or JSP로 처리하던 것을 controller와 view라는 영역으로 역할을 나눔!
- 보통 웹 어플리케이션은 보통 **mvc 패턴**을 사용
    - **컨트롤러** : http요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행함
    - **모델** : 뷰에 출력할 데이터를 담아둠, 뷰가 필요한 데이터를 모두 모델에 담아 전달해주는 덕분 뷰는 비즈니스 로직 or 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있음
    - **뷰** : 모델에 담겨있는 데이터를 사용해 화면을 그리는 일에 집중함, html을 생성하는 부분을 말함

`.getRequestDispatcher(viewPath);` → controller에서 view로 이동할 때 사용

`dispatcher.forward(request, response);` → 다른 서블릿이나 JSP로 이동할 수 있는 기능 / 서버 내부에서 다시 호출이 발생함

`WEB-INF`안의 폴더들은 외부에서 호출해도 호출되지 않는다는 WAS 서버의 룰!
